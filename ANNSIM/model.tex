\section{The model}
\label{sec:model}

\subsection{Overview}

An abstract \textbf{opinion space} is represented as a continuous
$I_N$-dimensional Euclidean space, where $I_N$ is the number of issues. An
\textbf{opinion} $O_i$ on \textbf{issue} $I_i$ is a value in the real interval
$[0,1]$, for $1 \leq i \leq I_N$.

There are two kinds of agents in the model: $C_N$ \textbf{candidates}, and
$V_N$ \textbf{voters}. Agents of either type each have a dynamic
\textbf{opinion vector} $(O_{i_1}, O_{i_2}, O_{i_3}, ..., O_{i_{I_N}})$
comprising one opinion on each issue; in other words, a point in the opinion
space.

A random Erd\H{o}s-R\'{e}enyi graph\cite{erdhos_evolution_1960} is generated
with $V_N$ nodes and uniform edge probability of $p_e$. During each iteration
of the simulation, voters interact randomly with their graph neighbors in
pairwise fashion, as explained below. This often results in one of the opinions
of one voter in the pair being moved either higher or lower in the interval.
We term this movement of voter opinions ``\textbf{drifting}.''

Every $E$ (``election interval'') iterations, each candidate adjusts (within
constraints) its opinion vector to the point in opinion space that would
produce the maximum number of votes assuming (1) all voter agents vote
rationally (\textit{i.e.} they will vote for the candidate whose opinion vector
is closest to theirs in opinion space) and (2) no other candidates' opinion
vector changes. We term this movement of candidate opinions
``\textbf{chasing}.''

\subsection{Voter agents}

At each iteration of the simulation, each agent $V_i$ (in randomly-chosen
order) has the opportunity to be influenced according to the
\textbf{cross-issue influence} (CI2) algorithm\cite{davies_agent-based_2023}.
To do so, it chooses one of its graph neighbors $V_j$ at random. It also
selects two of the $I_N$ issues, $I_c$ and $I_f$ (with $I_c \neq I_f$) as the
\textbf{comparison issue} and the \textbf{influenced issue}, respectively.

Agent $V_i$ then compares its opinion on issue $I_c$ ($O_{i_c}$) with agent
$V_j$'s opinion on that issue ($O_{j_c}$). If $|O_{i_c} - O_{j_c}| < T_o$,
where $T_o$ is the \textbf{openness threshold}, agent $V_i$ considers $V_j$ to
be homophilous and therefore trustworthy. It will then move its opinion on
$I_f$ ($O_{i_f}$) to be the average of its current value and agent $V_j$'s
value on $I_f$ ($O_{j_f}$). (For example, suppose issue 9 is chosen as the
comparison issue and issue 2 is chosen as the influenced issue. Then suppose
$O_{i_9} = .2, O_{j_9} = .4$, and $T_o = .15$. Since $|O_{i_9} - O_{j_9}| = .2
< .15$, $O_{i_2}$ will be influenced midway towards $O_{j_2}$, and settle at
.3.)

On the other hand, if $|V_i - V_j| > T_p$, where $T_p$ is the \textbf{pushaway
threshold}, agent $V_i$ considers $V_j$ to be so dissimilar that its opinion on
the influenced issue $T_f$ will be repelled. In this case, agent $V_i$ will
move its opinion on $I_f$ to be midway between its current position and that of
the pole (either 0 or 1). (For example, suppose issue 4 is chosen as the
comparison issue and issue 5 is chosen as the influenced issue. Then suppose
$O_{i_4} = .2, O_{j_4} = .9$, and $T_p = .6$. Since $|O_{i_4} - O_{j_4}| = .7
> .6$, $O_{i_5}$ will be pushed away from $O_{j_5}$, and settle at .1.)

Finally, each agent is endowed with a \textbf{party} variable, indicating which
party they are affiliated with at simulation's start. This is initialized by
simply assigning each agent the party whose candidate is closest to them in
opinion space. As the simulation progresses, and both voters and candidates
adjust their opinions, an agent may drift closer to the agents in a different
party than the one they are currently assigned to. A \textbf{party switch
threshold} $T_s$ establishes a hysteresis effect: an agent's distance to a
different party's centroid must be at least $T_s$ smaller than their distance
to their current party's centroid in order for a party switch to occur. In this
case, the agent is simply reassigned to the new party.

\subsection{Elections}

To study the political impact of the CI2 mechanism and explore the effects of
issue-based campaigning and voting, we introduce elections to the model.
Elections are held every $E=50$ iterations and results are tabulated to
determine both the winner and the rationality of the outcome. An election
outcome is considered \textbf{rational} if the winning candidate is the
candidate that best represents the population in opinion space. Put another
way, an election outcome is rational if the candidate who actually wins is the
same candidate who \textit{would} have won if all agents had been using the
rational voting algorithm (see section~\ref{votingAlgorithms}, below). This is
in line with how Redlawsk and Habegger describe an individual ``\textbf{voting
correctly}, or matching their values to the candidate who represents them most
accurately,''\cite[p.8]{redlawsk_citizens_2020} (emphasis original) except that
we look at the outcome of the entire election instead of just a single voter.

\subsubsection{Voting algorithms}
\label{votingAlgorithms}

% (Skipping Bounded Rational (or "Constrained Rational"))

Each voter agent is assigned one of several voting algorithms at
initialization, which model the discrepancies in the thinking patterns and
decision-making strategies of real voters. At election time, a voter uses this
algorithm to cast their ballot for a candidate. Derived from the literature on
voter psychology\cite[ch.2]{redlawsk_citizens_2020}, our four voting algorithms
are as follows: \textbf{rational}, \textbf{party-line}, \textbf{fast \& frugal
\#1} (F\&F1), and \textbf{fast \& frugal \#2} (F\&F2). The simulation makes it
possible to adjust what proportion of the electorate's voters will be assigned
each of the four algorithms, enabling the ``\textbf{voting algorithm
distribution}'' to be treated as an independent variable.

Rational agents simply vote for the candidate they are closest to in Euclidean
opinion space. They are an ideal-type voter, representing someone with perfect
information and the ability to maximize utility.

Party-line agents vote for the candidate that belongs to the party they
themselves are affiliated with. Thus they vote in a manner that simply
reaffirms their identity as a party member, ignoring positions on issues
entirely.

F\&F1 agents are each randomly assigned one ``core issue'' at initialization.
This remains their core issue through the entire simulation, and solely
determines how they vote: instead of choosing the candidate closest in
$I_N$-dimensional opinion space, as rational voters do, F\&F1 voters simply
choose the candidate closest to them on their core issue.

F\&F2 agents similarly vote based on a single issue, but it is a ``hot topic''
issue that all F\&F2 agents share, and which changes randomly with each
election cycle. Thus in contrast to F\&F1, all F\&F2 voters use the same issue
to make their decision.

Both kinds of F\&F agents represent voters who make a calculated trade-off
between a good decision and an easy decision. They do not consider all
information, only that which is most important to them, and cast their votes
based on that limited information, seeing as it is ``good enough'' (or
``satisficing''\cite{simon_rational_1956}).


\subsection{Parties}

%3. Parties **(HP)**
%    1. How these are initialized, both for voters and candidates
%    2. Whether and how voters ever change parties

We initialize parties to represent each of the candidates

\subsection{Candidate agents}

%4. Candidate agents **(HP)**
%    1. They have opinions just like agents do
%    2. They are assigned to a party, and initially determine what party each
%    agent is assigned to.
%    2. The "chase" algorithm
%         Define the terms "chasing candidate" and "non-chasing candidate"

